name: Deploy to Staging

on:
  workflow_call:
    inputs:
      lock-path:
        description: 'Relative path of the lock file in the repository'
        required: true
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: staging
    timeout-minutes: 10
    env:
      KUBECONFIG: /tmp/kubeconfig
      NAMESPACE: shopifake-staging

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0

      - name: Setup kubeconfig
        env:
          KUBECONFIG_BASE64: ${{ secrets.KUBECONFIG }}
        run: |
          echo "$KUBECONFIG_BASE64" | base64 -d > $KUBECONFIG
          chmod 600 $KUBECONFIG

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.0'

      - name: Install helm
        uses: azure/setup-helm@v4
        with:
          version: 'v3.15.0'

      - name: Cache helm repositories
        uses: actions/cache@v4
        with:
          path: ~/.cache/helm/repository
          key: ${{ runner.os }}-helm-repo-${{ hashFiles('.github/workflows/merge-staging-deploy.yml') }}
          restore-keys: |
            ${{ runner.os }}-helm-repo-

      - name: Setup helm repositories
        run: |
          helm repo add bitnami https://charts.bitnami.com/bitnami 2>/dev/null || true
          helm repo update

      - name: Parse lock file
        id: parse
        run: |
          jq -r '.services | keys[]' ${{ inputs.lock-path }} > /tmp/services.txt
          echo "Services: $(cat /tmp/services.txt | tr '\n' ' ')"

      - name: Deploy databases
        env:
          DB_PASSWORD_ACCESS: ${{ secrets.DB_PASSWORD_ACCESS }}
          DB_PASSWORD_AUDIT: ${{ secrets.DB_PASSWORD_AUDIT }}
          DB_PASSWORD_CATALOG: ${{ secrets.DB_PASSWORD_CATALOG }}
          DB_PASSWORD_CUSTOMERS: ${{ secrets.DB_PASSWORD_CUSTOMERS }}
          DB_PASSWORD_INVENTORY: ${{ secrets.DB_PASSWORD_INVENTORY }}
          DB_PASSWORD_ORDERS: ${{ secrets.DB_PASSWORD_ORDERS }}
          DB_PASSWORD_PRICING: ${{ secrets.DB_PASSWORD_PRICING }}
          DB_PASSWORD_SALES_DASHBOARD: ${{ secrets.DB_PASSWORD_SALES_DASHBOARD }}
          DB_PASSWORD_SITES: ${{ secrets.DB_PASSWORD_SITES }}
        run: |
          while read -r SERVICE_NAME; do
            # Get submodule path to filter services
            SUBMODULE_PATH=$(jq -r ".services[\"$SERVICE_NAME\"].submodule_path" ${{ inputs.lock-path }})
            
            # Only deploy databases for Java services in services/ directory
            if [[ ! "$SUBMODULE_PATH" == services/* ]]; then
              echo "Skipping $SERVICE_NAME (not in services/)"
              continue
            fi
            
            # Exclude Python services
            if [[ "$SERVICE_NAME" == "shopifake-recommender" || "$SERVICE_NAME" == "shopifake-chatbot" ]]; then
              echo "Skipping $SERVICE_NAME (Python service)"
              continue
            fi
          
            DB_NAME="${SERVICE_NAME}-db"
          
            if helm list -n $NAMESPACE | grep -q "^$DB_NAME"; then
              echo "Database $DB_NAME already exists, skipping"
              continue
            fi
          
            echo "Deploying PostgreSQL for $SERVICE_NAME"
          
            SERVICE_UPPER=$(echo "$SERVICE_NAME" | tr '[:lower:]-' '[:upper:]_' | sed 's/SHOPIFAKE_//')
            DB_PASSWORD_VAR="DB_PASSWORD_${SERVICE_UPPER}"
            DB_PASSWORD="${!DB_PASSWORD_VAR}"
          
            helm install "$DB_NAME" bitnami/postgresql \
              --namespace $NAMESPACE \
              --set auth.database="${SERVICE_NAME//-/_}_db" \
              --set auth.username="${SERVICE_NAME//-/_}_user" \
              --set auth.password="$DB_PASSWORD" \
              --set primary.persistence.size=1Gi \
              --wait \
              --timeout 5m
          
            echo "Database $DB_NAME deployed"
          done < /tmp/services.txt

      - name: Create configmaps
        env:
          CORS_ALLOWED_ORIGINS: ${{ secrets.CORS_ALLOWED_ORIGINS }}
          CORS_ALLOW_CREDENTIALS: ${{ secrets.CORS_ALLOW_CREDENTIALS }}
        run: |
          while read -r SERVICE_NAME; do
            # Get submodule path to filter services
            SUBMODULE_PATH=$(jq -r ".services[\"$SERVICE_NAME\"].submodule_path" ${{ inputs.lock-path }})
            
            # Only create configmaps for Java services in services/ directory
            if [[ ! "$SUBMODULE_PATH" == services/* ]]; then
              echo "Skipping $SERVICE_NAME (not in services/)"
              continue
            fi
            
            # Exclude Python services
            if [[ "$SERVICE_NAME" == "shopifake-recommender" || "$SERVICE_NAME" == "shopifake-chatbot" ]]; then
              echo "Skipping $SERVICE_NAME (Python service)"
              continue
            fi
          
            kubectl create configmap "${SERVICE_NAME}-config" \
              --from-literal=SPRING_PROFILES_ACTIVE=prod \
              --from-literal=DB_HOST="${SERVICE_NAME}-db-postgresql" \
              --from-literal=DB_PORT=5432 \
              --from-literal=DB_NAME="${SERVICE_NAME//-/_}_db" \
              --from-literal=DB_USERNAME="${SERVICE_NAME//-/_}_user" \
              --from-literal=PORT=8080 \
              --from-literal=CORS_ALLOWED_ORIGINS="$CORS_ALLOWED_ORIGINS" \
              --from-literal=CORS_ALLOW_CREDENTIALS="$CORS_ALLOW_CREDENTIALS" \
              --namespace $NAMESPACE \
              --dry-run=client -o yaml | kubectl apply -f -
          
            echo "ConfigMap ${SERVICE_NAME}-config applied"
          done < /tmp/services.txt

      - name: Create secrets
        env:
          DB_PASSWORD_ACCESS: ${{ secrets.DB_PASSWORD_ACCESS }}
          DB_PASSWORD_AUDIT: ${{ secrets.DB_PASSWORD_AUDIT }}
          DB_PASSWORD_CATALOG: ${{ secrets.DB_PASSWORD_CATALOG }}
          DB_PASSWORD_CUSTOMERS: ${{ secrets.DB_PASSWORD_CUSTOMERS }}
          DB_PASSWORD_INVENTORY: ${{ secrets.DB_PASSWORD_INVENTORY }}
          DB_PASSWORD_ORDERS: ${{ secrets.DB_PASSWORD_ORDERS }}
          DB_PASSWORD_PRICING: ${{ secrets.DB_PASSWORD_PRICING }}
          DB_PASSWORD_SALES_DASHBOARD: ${{ secrets.DB_PASSWORD_SALES_DASHBOARD }}
          DB_PASSWORD_SITES: ${{ secrets.DB_PASSWORD_SITES }}
        run: |
          while read -r SERVICE_NAME; do
            # Get submodule path to filter services
            SUBMODULE_PATH=$(jq -r ".services[\"$SERVICE_NAME\"].submodule_path" ${{ inputs.lock-path }})
            
            # Only create secrets for Java services in services/ directory
            if [[ ! "$SUBMODULE_PATH" == services/* ]]; then
              echo "Skipping $SERVICE_NAME (not in services/)"
              continue
            fi
            
            # Exclude Python services
            if [[ "$SERVICE_NAME" == "shopifake-recommender" || "$SERVICE_NAME" == "shopifake-chatbot" ]]; then
              echo "Skipping $SERVICE_NAME (Python service)"
              continue
            fi
          
            SERVICE_UPPER=$(echo "$SERVICE_NAME" | tr '[:lower:]-' '[:upper:]_' | sed 's/SHOPIFAKE_//')
            DB_PASSWORD_VAR="DB_PASSWORD_${SERVICE_UPPER}"
            DB_PASSWORD="${!DB_PASSWORD_VAR}"
          
            kubectl create secret generic "${SERVICE_NAME}-secret" \
              --from-literal=DB_PASSWORD="$DB_PASSWORD" \
              --namespace $NAMESPACE \
              --dry-run=client -o yaml | kubectl apply -f -
          
            echo "Secret ${SERVICE_NAME}-secret applied"
          done < /tmp/services.txt

      - name: Deploy services
        run: |
          while read -r SERVICE_NAME; do
            # Get submodule path to filter services
            SUBMODULE_PATH=$(jq -r ".services[\"$SERVICE_NAME\"].submodule_path" ${{ inputs.lock-path }})
            
            # Only deploy Java services in services/ directory
            if [[ ! "$SUBMODULE_PATH" == services/* ]]; then
              echo "Skipping $SERVICE_NAME (not in services/)"
              continue
            fi
            
            # Exclude Python services
            if [[ "$SERVICE_NAME" == "shopifake-recommender" || "$SERVICE_NAME" == "shopifake-chatbot" ]]; then
              echo "Skipping $SERVICE_NAME (Python service)"
              continue
            fi
          
            IMAGE_REPO=$(jq -r ".services[\"$SERVICE_NAME\"].image.repository" ${{ inputs.lock-path }})
            IMAGE_TAG=$(jq -r ".services[\"$SERVICE_NAME\"].image.tag" ${{ inputs.lock-path }})
            CHART_PATH=$(jq -r ".services[\"$SERVICE_NAME\"].submodule_path" ${{ inputs.lock-path }})
          
            echo "Deploying $SERVICE_NAME"
            echo "  Image: $IMAGE_REPO:$IMAGE_TAG"
            echo "  Chart: $CHART_PATH/chart"
          
            if [ ! -d "$CHART_PATH/chart" ]; then
              echo "Error: Chart not found at $CHART_PATH/chart"
              exit 1
            fi
          
            helm upgrade --install "$SERVICE_NAME" "$CHART_PATH/chart" \
              --namespace $NAMESPACE \
              --set image.repository="$IMAGE_REPO" \
              --set image.tag="$IMAGE_TAG" \
              --set "envFrom[0].configMapRef.name=${SERVICE_NAME}-config" \
              --set "envFrom[1].secretRef.name=${SERVICE_NAME}-secret" \
              --wait \
              --timeout 5m
          
            echo "Service $SERVICE_NAME deployed"
          done < /tmp/services.txt

      - name: Verify deployment
        if: always()
        run: |
          echo "Deployment status:"
          kubectl get pods -n $NAMESPACE -o wide