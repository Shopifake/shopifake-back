name: Deploy to Staging

on:
  workflow_call:
    inputs:
      lock-path:
        description: 'Relative path of the lock file in the repository'
        required: true
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: staging
    timeout-minutes: 10
    env:
      KUBECONFIG: /tmp/kubeconfig
      NAMESPACE: shopifake-staging

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0

      - name: Setup kubeconfig
        env:
          KUBECONFIG_BASE64: ${{ secrets.KUBECONFIG }}
        run: |
          echo "$KUBECONFIG_BASE64" | base64 -d > $KUBECONFIG
          chmod 600 $KUBECONFIG

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.0'

      - name: Install helm
        uses: azure/setup-helm@v4
        with:
          version: 'v3.15.0'

      - name: Cache helm repositories
        uses: actions/cache@v4
        with:
          path: ~/.cache/helm/repository
          key: ${{ runner.os }}-helm-repo-${{ hashFiles('.github/workflows/merge-staging-deploy.yml') }}
          restore-keys: |
            ${{ runner.os }}-helm-repo-

      - name: Setup helm repositories
        run: |
          helm repo add bitnami https://charts.bitnami.com/bitnami 2>/dev/null || true
          helm repo update

      - name: Parse lock file
        id: parse
        run: |
          jq -r '.services | keys[]' ${{ inputs.lock-path }} > /tmp/services.txt
          echo "Services: $(cat /tmp/services.txt | tr '\n' ' ')"

      - name: Deploy Python service dependencies
        run: |
          # Deploy Redis for Python services (used by recommender for queue)
          if ! helm list -n $NAMESPACE | grep -q "^shopifake-redis"; then
            echo "Deploying Redis for Python services"
            helm install shopifake-redis bitnami/redis \
              --version 24.0.0 \
              --namespace $NAMESPACE \
              --set auth.enabled=false \
              --set master.persistence.size=1Gi \
              --set replica.replicaCount=0 \
              --wait \
              --timeout 3m
            echo "Redis deployed"
          else
            echo "Redis already exists, skipping"
          fi
          
          # Deploy Qdrant for recommender service (vector database)
          if ! kubectl get deployment shopifake-qdrant -n $NAMESPACE &>/dev/null; then
            echo "Deploying Qdrant vector database"
            
            # Check if recommender service is in the lock file
            if grep -q "shopifake-recommender" /tmp/services.txt; then
              RECOMMENDER_PATH=$(jq -r '.services["shopifake-recommender"].submodule_path' ${{ inputs.lock-path }})
              
              if [ -f "$RECOMMENDER_PATH/chart/qdrant-deployment.yaml" ]; then
                kubectl apply -f "$RECOMMENDER_PATH/chart/qdrant-deployment.yaml"
                
                # Wait for Qdrant to be ready
                kubectl wait --for=condition=ready pod -l app=shopifake-qdrant \
                  -n $NAMESPACE --timeout=120s || true
                
                echo "Qdrant deployed"
              else
                echo "Warning: Qdrant manifest not found at $RECOMMENDER_PATH/chart/qdrant-deployment.yaml"
              fi
            else
              echo "Recommender service not in lock file, skipping Qdrant"
            fi
          else
            echo "Qdrant already exists, skipping"
          fi

      - name: Deploy shared PostgreSQL database
        env:
          POSTGRES_ADMIN_PASSWORD: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
          DB_PASSWORD_ACCESS: ${{ secrets.DB_PASSWORD_ACCESS }}
          DB_PASSWORD_AUDIT: ${{ secrets.DB_PASSWORD_AUDIT }}
          DB_PASSWORD_CATALOG: ${{ secrets.DB_PASSWORD_CATALOG }}
          DB_PASSWORD_CUSTOMERS: ${{ secrets.DB_PASSWORD_CUSTOMERS }}
          DB_PASSWORD_INVENTORY: ${{ secrets.DB_PASSWORD_INVENTORY }}
          DB_PASSWORD_ORDERS: ${{ secrets.DB_PASSWORD_ORDERS }}
          DB_PASSWORD_PRICING: ${{ secrets.DB_PASSWORD_PRICING }}
          DB_PASSWORD_SALES_DASHBOARD: ${{ secrets.DB_PASSWORD_SALES_DASHBOARD }}
          DB_PASSWORD_SITES: ${{ secrets.DB_PASSWORD_SITES }}
          DB_PASSWORD_CHATBOT: ${{ secrets.DB_PASSWORD_CHATBOT }}
          DB_PASSWORD_RECOMMENDER: ${{ secrets.DB_PASSWORD_RECOMMENDER }}
          DB_PASSWORD_AUTH_B2C: ${{ secrets.DB_PASSWORD_AUTH_B2C }}
          DB_PASSWORD_AUTH_B2E: ${{ secrets.DB_PASSWORD_AUTH_B2E }}
        run: |
          # Deploy single PostgreSQL 16 instance with all databases
          if helm list -n $NAMESPACE | grep -q "^shopifake-postgres"; then
            echo "PostgreSQL already exists, skipping installation"
          else
            echo "Deploying shared PostgreSQL instance..."
            helm install shopifake-postgres bitnami/postgresql \
              --namespace $NAMESPACE \
              --set auth.postgresPassword="$POSTGRES_ADMIN_PASSWORD" \
              --set primary.persistence.size=10Gi \
              --set primary.resources.requests.cpu=250m \
              --set primary.resources.requests.memory=512Mi \
              --set primary.resources.limits.cpu=1000m \
              --set primary.resources.limits.memory=1Gi \
              --wait \
              --timeout 5m
            echo "PostgreSQL deployed"
          fi
          
          # Wait for PostgreSQL to be ready
          echo "Waiting for PostgreSQL to be ready..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=postgresql \
            -n $NAMESPACE --timeout=180s
          
          # Initialize databases, users and privileges
          echo "Initializing databases..."
          POSTGRES_POD=$(kubectl get pod -n $NAMESPACE -l app.kubernetes.io/name=postgresql -o jsonpath='{.items[0].metadata.name}')
          
          # Copy SQL script to pod
          kubectl cp scripts/init-databases-cicd.sql $NAMESPACE/$POSTGRES_POD:/tmp/init-databases.sql
          
          # Execute initialization script
          kubectl exec -n $NAMESPACE "$POSTGRES_POD" -- env \
            PGPASSWORD="$POSTGRES_ADMIN_PASSWORD" \
            DB_PASSWORD_ACCESS="$DB_PASSWORD_ACCESS" \
            DB_PASSWORD_AUDIT="$DB_PASSWORD_AUDIT" \
            DB_PASSWORD_CATALOG="$DB_PASSWORD_CATALOG" \
            DB_PASSWORD_CUSTOMERS="$DB_PASSWORD_CUSTOMERS" \
            DB_PASSWORD_INVENTORY="$DB_PASSWORD_INVENTORY" \
            DB_PASSWORD_ORDERS="$DB_PASSWORD_ORDERS" \
            DB_PASSWORD_PRICING="$DB_PASSWORD_PRICING" \
            DB_PASSWORD_SALES_DASHBOARD="$DB_PASSWORD_SALES_DASHBOARD" \
            DB_PASSWORD_SITES="$DB_PASSWORD_SITES" \
            DB_PASSWORD_CHATBOT="$DB_PASSWORD_CHATBOT" \
            DB_PASSWORD_RECOMMENDER="$DB_PASSWORD_RECOMMENDER" \
            DB_PASSWORD_AUTH_B2C="$DB_PASSWORD_AUTH_B2C" \
            DB_PASSWORD_AUTH_B2E="$DB_PASSWORD_AUTH_B2E" \
            psql -U postgres \
              -v DB_PASSWORD_ACCESS="$DB_PASSWORD_ACCESS" \
              -v DB_PASSWORD_AUDIT="$DB_PASSWORD_AUDIT" \
              -v DB_PASSWORD_CATALOG="$DB_PASSWORD_CATALOG" \
              -v DB_PASSWORD_CUSTOMERS="$DB_PASSWORD_CUSTOMERS" \
              -v DB_PASSWORD_INVENTORY="$DB_PASSWORD_INVENTORY" \
              -v DB_PASSWORD_ORDERS="$DB_PASSWORD_ORDERS" \
              -v DB_PASSWORD_PRICING="$DB_PASSWORD_PRICING" \
              -v DB_PASSWORD_SALES_DASHBOARD="$DB_PASSWORD_SALES_DASHBOARD" \
              -v DB_PASSWORD_SITES="$DB_PASSWORD_SITES" \
              -v DB_PASSWORD_CHATBOT="$DB_PASSWORD_CHATBOT" \
              -v DB_PASSWORD_RECOMMENDER="$DB_PASSWORD_RECOMMENDER" \
              -v DB_PASSWORD_AUTH_B2C="$DB_PASSWORD_AUTH_B2C" \
              -v DB_PASSWORD_AUTH_B2E="$DB_PASSWORD_AUTH_B2E" \
              -f /tmp/init-databases.sql
          
          echo "Database initialization complete"

      - name: Create configmaps and secrets
        env:
          # Variables (ConfigMaps)
          SHOPIFAKE_ACCESS_CONFIGMAP: ${{ vars.SHOPIFAKE_ACCESS_CONFIGMAP }}
          SHOPIFAKE_AUDIT_CONFIGMAP: ${{ vars.SHOPIFAKE_AUDIT_CONFIGMAP }}
          SHOPIFAKE_CATALOG_CONFIGMAP: ${{ vars.SHOPIFAKE_CATALOG_CONFIGMAP }}
          SHOPIFAKE_CUSTOMERS_CONFIGMAP: ${{ vars.SHOPIFAKE_CUSTOMERS_CONFIGMAP }}
          SHOPIFAKE_INVENTORY_CONFIGMAP: ${{ vars.SHOPIFAKE_INVENTORY_CONFIGMAP }}
          SHOPIFAKE_ORDERS_CONFIGMAP: ${{ vars.SHOPIFAKE_ORDERS_CONFIGMAP }}
          SHOPIFAKE_PRICING_CONFIGMAP: ${{ vars.SHOPIFAKE_PRICING_CONFIGMAP }}
          SHOPIFAKE_SALES_DASHBOARD_CONFIGMAP: ${{ vars.SHOPIFAKE_SALES_DASHBOARD_CONFIGMAP }}
          SHOPIFAKE_SITES_CONFIGMAP: ${{ vars.SHOPIFAKE_SITES_CONFIGMAP }}
          SHOPIFAKE_RECOMMENDER_CONFIGMAP: ${{ vars.SHOPIFAKE_RECOMMENDER_CONFIGMAP }}
          SHOPIFAKE_CHATBOT_CONFIGMAP: ${{ vars.SHOPIFAKE_CHATBOT_CONFIGMAP }}
          SHOPIFAKE_AUTH_B2C_CONFIGMAP: ${{ vars.SHOPIFAKE_AUTH_B2C_CONFIGMAP }}
          SHOPIFAKE_AUTH_B2E_CONFIGMAP: ${{ vars.SHOPIFAKE_AUTH_B2E_CONFIGMAP }}
          # Secrets
          SHOPIFAKE_ACCESS_SECRETS: ${{ secrets.SHOPIFAKE_ACCESS_SECRETS }}
          SHOPIFAKE_AUDIT_SECRETS: ${{ secrets.SHOPIFAKE_AUDIT_SECRETS }}
          SHOPIFAKE_CATALOG_SECRETS: ${{ secrets.SHOPIFAKE_CATALOG_SECRETS }}
          SHOPIFAKE_CUSTOMERS_SECRETS: ${{ secrets.SHOPIFAKE_CUSTOMERS_SECRETS }}
          SHOPIFAKE_INVENTORY_SECRETS: ${{ secrets.SHOPIFAKE_INVENTORY_SECRETS }}
          SHOPIFAKE_ORDERS_SECRETS: ${{ secrets.SHOPIFAKE_ORDERS_SECRETS }}
          SHOPIFAKE_PRICING_SECRETS: ${{ secrets.SHOPIFAKE_PRICING_SECRETS }}
          SHOPIFAKE_SALES_DASHBOARD_SECRETS: ${{ secrets.SHOPIFAKE_SALES_DASHBOARD_SECRETS }}
          SHOPIFAKE_SITES_SECRETS: ${{ secrets.SHOPIFAKE_SITES_SECRETS }}
          SHOPIFAKE_RECOMMENDER_SECRETS: ${{ secrets.SHOPIFAKE_RECOMMENDER_SECRETS }}
          SHOPIFAKE_CHATBOT_SECRETS: ${{ secrets.SHOPIFAKE_CHATBOT_SECRETS }}
          SHOPIFAKE_AUTH_B2C_SECRETS: ${{ secrets.SHOPIFAKE_AUTH_B2C_SECRETS }}
          SHOPIFAKE_AUTH_B2E_SECRETS: ${{ secrets.SHOPIFAKE_AUTH_B2E_SECRETS }}
        run: |
          while read -r SERVICE_NAME; do
            # Get submodule path to filter services
            SUBMODULE_PATH=$(jq -r ".services[\"$SERVICE_NAME\"].submodule_path" ${{ inputs.lock-path }})
            
            # Handle services in services/ directory and auth services in infra/
            if [[ ! "$SUBMODULE_PATH" == services/* ]] && [[ ! "$SUBMODULE_PATH" == infra/shopifake-auth-* ]]; then
              echo "Skipping $SERVICE_NAME (not in services/ or auth service)"
              continue
            fi
            
            echo "=== Processing $SERVICE_NAME ==="
            
            # Convert service name to uppercase with underscores
            SERVICE_NAME_UPPER=$(echo "$SERVICE_NAME" | tr '[:lower:]-' '[:upper:]_')
            CONFIGMAP_VAR="${SERVICE_NAME_UPPER}_CONFIGMAP"
            SECRETS_VAR="${SERVICE_NAME_UPPER}_SECRETS"
            
            # Get the configmap and secrets content
            CONFIGMAP_CONTENT="${!CONFIGMAP_VAR}"
            SECRETS_CONTENT="${!SECRETS_VAR}"
            
            # Validate that both are set
            if [ -z "$CONFIGMAP_CONTENT" ]; then
              echo "Error: $CONFIGMAP_VAR is not set"
              exit 1
            fi
            
            if [ -z "$SECRETS_CONTENT" ]; then
              echo "Error: $SECRETS_VAR is not set"
              exit 1
            fi
            
            # Create ConfigMap
            echo "$CONFIGMAP_CONTENT" > /tmp/configmap-${SERVICE_NAME}.env
            kubectl create configmap "${SERVICE_NAME}-config" \
              --from-env-file=/tmp/configmap-${SERVICE_NAME}.env \
              --namespace $NAMESPACE \
              --dry-run=client -o yaml | kubectl apply -f -
            rm -f /tmp/configmap-${SERVICE_NAME}.env
            echo "✓ ConfigMap ${SERVICE_NAME}-config applied"
            
            # Create Secret
            echo "$SECRETS_CONTENT" > /tmp/secret-${SERVICE_NAME}.env
            kubectl create secret generic "${SERVICE_NAME}-secret" \
              --from-env-file=/tmp/secret-${SERVICE_NAME}.env \
              --namespace $NAMESPACE \
              --dry-run=client -o yaml | kubectl apply -f -
            rm -f /tmp/secret-${SERVICE_NAME}.env
            echo "✓ Secret ${SERVICE_NAME}-secret applied"
            
            echo ""
          done < /tmp/services.txt

      - name: Deploy services
        run: |
          while read -r SERVICE_NAME; do
            # Get submodule path to filter services
            SUBMODULE_PATH=$(jq -r ".services[\"$SERVICE_NAME\"].submodule_path" ${{ inputs.lock-path }})
            
            # Deploy services in services/ directory and auth services in infra/
            if [[ ! "$SUBMODULE_PATH" == services/* ]] && [[ ! "$SUBMODULE_PATH" == infra/shopifake-auth-* ]]; then
              echo "Skipping $SERVICE_NAME (not in services/ or auth service)"
              continue
            fi
          
            IMAGE_REPO=$(jq -r ".services[\"$SERVICE_NAME\"].image.repository" ${{ inputs.lock-path }})
            IMAGE_TAG=$(jq -r ".services[\"$SERVICE_NAME\"].image.tag" ${{ inputs.lock-path }})
            CHART_PATH=$(jq -r ".services[\"$SERVICE_NAME\"].submodule_path" ${{ inputs.lock-path }})
          
            echo "Deploying $SERVICE_NAME"
            echo "  Image: $IMAGE_REPO:$IMAGE_TAG"
            echo "  Chart: $CHART_PATH/chart"
          
            if [ ! -d "$CHART_PATH/chart" ]; then
              echo "Error: Chart not found at $CHART_PATH/chart"
              exit 1
            fi
          
            # Get ConfigMap hash to force restart when config changes
            CONFIGMAP_HASH=$(kubectl get configmap "${SERVICE_NAME}-config" -n $NAMESPACE -o json 2>/dev/null | sha256sum | awk '{print $1}' || echo "")
            
            helm upgrade --install "$SERVICE_NAME" "$CHART_PATH/chart" \
              --namespace $NAMESPACE \
              --set image.repository="$IMAGE_REPO" \
              --set image.tag="$IMAGE_TAG" \
              --set "envFrom[0].configMapRef.name=${SERVICE_NAME}-config" \
              --set "envFrom[1].secretRef.name=${SERVICE_NAME}-secret" \
              --set "podAnnotations.configmap-hash=${CONFIGMAP_HASH}"
          
            echo "Service $SERVICE_NAME deployed (waiting for health check)"
          done < /tmp/services.txt

      - name: Create gateway configmap
        env:
          CORS_ALLOWED_ORIGINS: ${{ secrets.CORS_ALLOWED_ORIGINS }}
          CORS_ALLOW_CREDENTIALS: ${{ secrets.CORS_ALLOW_CREDENTIALS }}
        run: |
          kubectl create configmap "shopifake-gateway-config" \
            --from-literal=SPRING_PROFILES_ACTIVE=prod \
            --from-literal=PORT=8080 \
            --from-literal=CORS_ALLOWED_ORIGINS="$CORS_ALLOWED_ORIGINS" \
            --from-literal=CORS_ALLOW_CREDENTIALS="$CORS_ALLOW_CREDENTIALS" \
            --from-literal=SERVICE_ACCESS_URL=http://shopifake-access:8080 \
            --from-literal=SERVICE_AUDIT_URL=http://shopifake-audit:8080 \
            --from-literal=SERVICE_CATALOG_URL=http://shopifake-catalog:8080 \
            --from-literal=SERVICE_CUSTOMERS_URL=http://shopifake-customers:8080 \
            --from-literal=SERVICE_INVENTORY_URL=http://shopifake-inventory:8080 \
            --from-literal=SERVICE_ORDERS_URL=http://shopifake-orders:8080 \
            --from-literal=SERVICE_PRICING_URL=http://shopifake-pricing:8080 \
            --from-literal=SERVICE_RECOMMENDER_URL=http://shopifake-recommender:8000 \
            --from-literal=SERVICE_SALES_DASHBOARD_URL=http://shopifake-sales-dashboard:8080 \
            --from-literal=SERVICE_SITES_URL=http://shopifake-sites:8080 \
            --from-literal=SERVICE_CHATBOT_URL=http://shopifake-chatbot:8000 \
            --from-literal=SERVICE_AUTH_B2C_URL=http://shopifake-auth-b2c:3000 \
            --from-literal=SERVICE_AUTH_B2E_URL=http://shopifake-auth-b2e:3000 \
            --namespace $NAMESPACE \
            --dry-run=client -o yaml | kubectl apply -f -
        
          echo "ConfigMap shopifake-gateway-config applied"

      - name: Create gateway secret
        env:
          BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET }}
        run: |
          kubectl create secret generic "shopifake-gateway-secret" \
            --from-literal=BETTER_AUTH_SECRET="$BETTER_AUTH_SECRET" \
            --namespace $NAMESPACE \
            --dry-run=client -o yaml | kubectl apply -f -
        
          echo "Secret shopifake-gateway-secret applied"

      - name: Deploy gateway
        run: |
          SERVICE_NAME="shopifake-gateway"
          
          # Check if gateway exists in lock file
          if ! jq -e ".services[\"$SERVICE_NAME\"]" ${{ inputs.lock-path }} > /dev/null; then
            echo "Gateway not found in lock file, skipping"
            exit 0
          fi
          
          IMAGE_REPO=$(jq -r ".services[\"$SERVICE_NAME\"].image.repository" ${{ inputs.lock-path }})
          IMAGE_TAG=$(jq -r ".services[\"$SERVICE_NAME\"].image.tag" ${{ inputs.lock-path }})
          CHART_PATH=$(jq -r ".services[\"$SERVICE_NAME\"].submodule_path" ${{ inputs.lock-path }})
        
          echo "Deploying $SERVICE_NAME"
          echo "  Image: $IMAGE_REPO:$IMAGE_TAG"
          echo "  Chart: $CHART_PATH/chart"
        
          if [ ! -d "$CHART_PATH/chart" ]; then
            echo "Error: Chart not found at $CHART_PATH/chart"
            exit 1
          fi
        
          # Get ConfigMap hash to force restart when config changes
          CONFIGMAP_HASH=$(kubectl get configmap "${SERVICE_NAME}-config" -n $NAMESPACE -o json 2>/dev/null | sha256sum | awk '{print $1}' || echo "")
          
          helm upgrade --install "$SERVICE_NAME" "$CHART_PATH/chart" \
            --namespace $NAMESPACE \
            --set image.repository="$IMAGE_REPO" \
            --set image.tag="$IMAGE_TAG" \
            --set "envFrom[0].configMapRef.name=${SERVICE_NAME}-config" \
            --set "envFrom[1].secretRef.name=${SERVICE_NAME}-secret" \
            --set "podAnnotations.configmap-hash=${CONFIGMAP_HASH}"
        
          echo "Gateway $SERVICE_NAME deployed (waiting for health check)"

      - name: Wait for all deployments
        run: |
          echo "Waiting for all deployments to be ready..."
          kubectl wait --for=condition=available deployment --all \
            --namespace $NAMESPACE \
            --timeout=10m
          echo "All deployments are ready!"

      - name: Verify deployment
        if: always()
        run: |
          echo "Deployment status:"
          kubectl get pods -n $NAMESPACE -o wide